#深入理解操作系统的系统调用
**张必红原创作品转载请注明出处《Linux内核分析》MOOC课程http://mooc.study.163.com/course/USTC-1000029000**
系统调用也是个中断，只不过他是操作系统为了方便用户程序需求而特殊设计的。因为用户程序可能经常需要向内核请求服务，比如读文件或者创建一个进程，或者加载一个新的进程。那为了对这些访问进行合理的控制，所以提供了一条受控的特殊指令（x86平台下是int 0x80）,当一旦执行这个命令之后，就会执行一些列的操作，下面我们将详细的来分析。

####系统调用过程
一旦执行系统调用命令以后，因为系统调用也是通过中断实现的，所以，它的操作跟中断类似。
1）保存现场，一般保存cs,eip,ss,esp,flags,这些寄存器。int 0x80指令一执行，这些保存工作会自动执行。
2）因为现场已经保存了，所以这些就会从用户太切换到内核态，用户栈也已经切换到内核栈了。接着，就根据中断向量来执行相应的终端处理程序。而尽管不同的系统调用的处理过程可能不一样，但是，他们第一步都是保存通用寄存器，即保存关于通用寄存器的上下文。
3）中断处理程序执行完成以后，如果没有中断嵌套，那么就会恢复通用寄存器的上下文了。
4）最后一步，从内核态再次切换到用太态，恢复到原来的执行流继续执行。

####write系统调用
下面，我们就用我自己实现的一个write调用来说明，系统调用具体是怎么一个过程的。源码如下
``` C
#include<stdio.h>
int main() {
   char *s = "hello,zbh\n";
   asm volatile (
	"movl $4,%%eax;\n\t"
	"movl $1,%%ebx;\n\t"
	"movl %0,%%ecx;\n\t"
	"movl $10,%%edx;\n\t"
	"int $0x80;\n\t"
	:
	:"D"(s)
	);
   return 0;
}
```
我要实现的write调用，系统调用号为4，我们要实现的打印字符串hello，zbh\n到屏幕上，长度为10.我们知道系统调用eax存放系统调用号，ebx,ecx,edx,esi,edi,ebp存放相应的参数，这样最多可以传递6个。但是，当超过了6个怎么办呢，我们可以用一个指针来实现，只需把指针地址传过去即可。
好的，wirte调用有三个参数，第一个是写到哪儿，linux默认有3个（0，1，2），分别代表输入流，输出流到屏幕，输出流到错误端。所以，这里我们让ebx为1，接着传递字串流的地址，所以把s的地址存放到ecx。接着，把长度为10存放到edx，这样三个参数就传过去了，最后调用int 0x80.最后，可以看到成功打印出。
如下图：
[!Write系统调用](http:www)
为了说明相关的概念，本文实现了两个程序，一个是通过库函数输出，另一个是直接通过系统调用实现。源代码都在本站上，其中wiite源代码在[write](https://github.com/zbh24/mykernel)
####总结
通过以上的说明和例子，大家应该可以看到系统调用是怎么实现的了。
